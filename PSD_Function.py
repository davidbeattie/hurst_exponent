import numpy as np
from scipy import signal

def PSD_2D(surface, pixelwidth):
    #surface : 2D topography generated by Hurst function.
    #pixelwidth: size of pixel in (SI Units (meters))
    
    n, m = surface.shape
    
    if (n % 2 != 0):
        n = n - 1
    
    if (m % 2 != 0):
        m = m - 1
    
    Lx = m * pixelwidth
    Ly = n * pixelwidth
    
    a = pixelwidth
    
    Hm = np.fft.fftshift(np.fft.fft2(surface, s = (n, m)))
    
    Cq = np.zeros((n, m), dtype = complex)
    Cq = (a ** 2 / ((n * m) * np.power((2 * np.pi), 2)) * (np.abs(Hm) ** 2))        
    Cq[int(n / 2), int(m / 2)] = 0
    
    qx = np.zeros((m, 1), dtype = float)
    for k in range(m):
        qx[k] = (2 * np.pi / m) * k
    
    qx2 = np.fft.fftshift(qx)
    qx3 = np.fft.fftshift(np.unwrap(qx2 - np.pi))
    qx = qx3 / a
    
    qy = np.zeros((n, 1), dtype = float)
    for j in range(n):
        qy[j] = (2 * np.pi / n) * j
    
    qy2 = np.fft.fftshift(qy)
    qy3 = np.fft.fftshift(np.unwrap(qy2 - np.pi))
    qy = qy3 / a
    
    qxx, qyy = np.meshgrid(qx, qy)

    rho = np.sqrt(qxx ** 2 + qyy ** 2)
    rhof = np.floor(rho)
    
    J = 1024
    
    qrmin = np.log10(np.sqrt(np.power((2 * np.pi / Lx), 2) + np.power((2 * np.pi / Ly), 2)))
    qrmax = np.log10(np.sqrt(qx[-1] ** 2 + qy[-1] ** 2)).item()
    q = np.floor(10 ** np.linspace(qrmin, qrmax, J))
    
    C_AVE = np.zeros([len(q)])
    ind = np.zeros([len(q)])

    for j in range(len(q)):
        ind = np.where(np.logical_and(rhof > q[j - 1], rhof <= q[j]))
        C_AVE[j] = np.nanmean(Cq[ind])
  
    ind = ~np.isnan(C_AVE)
    C = C_AVE[ind]
    q = q[ind]

    PSD = [Hm, C, q, Cq, qx, qy]
    
    return PSD